module Commands where

import Parsing
import Emit
import Obj
import Types
import Infer
import Deftype
import ColorText
import Template
import Util
import System.Directory
import System.Info (os)
import Control.Monad.State
import Control.Monad.State.Lazy (StateT(..), runStateT, liftIO, modify, get, put)
import System.Exit (exitSuccess, exitFailure, exitWith, ExitCode(..))
import qualified Data.Map as Map
import System.Process (callCommand, spawnCommand, waitForProcess)
import Control.Exception

type CommandCallback = [XObj] -> StateT Context IO (Either EvalError XObj)

data CarpException =
    ShellOutException { shellOutMessage :: String, returnCode :: Int }
  | CancelEvaluationException
  deriving (Eq, Show)

instance Exception CarpException

-- | A lot of commands need to return nil, which signifies a side effecting function and no printing of the result.
dynamicNil :: Either a XObj
dynamicNil = Right (XObj (Lst []) (Just dummyInfo) (Just UnitTy)) -- TODO: Remove/unwrap (Right ...) to a XObj

-- | Dynamic 'true'.
trueXObj :: XObj
trueXObj = XObj (Bol True) Nothing Nothing

-- | Dynamic 'false'.
falseXObj :: XObj
falseXObj = XObj (Bol False) Nothing Nothing

-- | Use this function to register commands in the environment.
addCommand :: String -> CommandFunctionType -> (String, Binder)
addCommand name callback =
  let path = SymPath [] name
      cmd = XObj (Lst [XObj (Command callback) (Just dummyInfo) Nothing
                      ,XObj (Sym path) Nothing Nothing
                      ])
            (Just dummyInfo) (Just DynamicTy)
  in (name, Binder cmd)

-- | Command for changing various project settings.
commandProjectSet :: CommandCallback
commandProjectSet [XObj (Str key) _ _, value] =
  do ctx <- get
     let proj = contextProj ctx
         env = contextGlobalEnv ctx
     case value of
       XObj (Str valueStr) _ _ -> do
          newCtx <- case key of
                      "cflag" -> return ctx { contextProj = proj { projectCFlags = addIfNotPresent valueStr (projectCFlags proj) } }
                      "libflag" -> return ctx { contextProj = proj { projectCFlags = addIfNotPresent valueStr (projectCFlags proj) } }
                      "prompt" -> return ctx { contextProj = proj { projectPrompt = valueStr } }
                      "search-path" -> return ctx { contextProj = proj { projectCarpSearchPaths = addIfNotPresent valueStr (projectCarpSearchPaths proj) } }
                      "printAST" -> return ctx { contextProj = proj { projectPrintTypedAST = (valueStr == "true") } }
                      "echoC" -> return ctx { contextProj = proj { projectEchoC = (valueStr == "true") } }
                      "echoCompilationCommand" -> return ctx { contextProj = proj { projectEchoCompilationCommand = (valueStr == "true") } }
                      "compiler" -> return ctx { contextProj = proj { projectCompiler = valueStr } }
                      _ -> err ("Unrecognized key: '" ++ key ++ "'") ctx
          put newCtx
          return dynamicNil
       val -> err "Argument to project-set! must be a string" dynamicNil
    where err msg ret = liftIO $ do putStrLnWithColor Red msg
                                    return ret
commandProjectSet args =
  liftIO $ do putStrLnWithColor Red ("Invalid args to 'project-set!' command: " ++ joinWithComma (map pretty args))
              return dynamicNil

-- | Command for exiting the REPL/compiler
commandQuit :: CommandCallback
commandQuit args =
  do liftIO exitSuccess
     return dynamicNil

-- | Command for printing the generated C output (in out/main.c)
commandCat :: CommandCallback
commandCat args =
  do ctx <- get
     let outDir = projectOutDir (contextProj ctx)
         outMain = outDir ++ "main.c"
     liftIO $ do callCommand ("cat -n " ++ outMain)
                 return dynamicNil

-- | Command for running the executable generated by the 'build' command.
commandRunExe :: CommandCallback
commandRunExe args =
  do ctx <- get
     let outDir = projectOutDir (contextProj ctx)
         outExe = outDir ++ "a.out"
     liftIO $ do handle <- spawnCommand outExe
                 exitCode <- waitForProcess handle
                 case exitCode of
                   ExitSuccess -> return (Right (XObj (Num IntTy 0) (Just dummyInfo) (Just IntTy)))
                   ExitFailure i -> throw (ShellOutException ("'" ++ outExe ++ "' exited with return value " ++ show i ++ ".") i)

-- | Command for building the project, producing an executable binary or a shared library.
commandBuild :: CommandCallback
commandBuild args =
  do ctx <- get
     let env = contextGlobalEnv ctx
         typeEnv = contextTypeEnv ctx
         proj = contextProj ctx
         execMode = contextExecMode ctx
         src = do decl <- envToDeclarations typeEnv env
                  typeDecl <- envToDeclarations typeEnv (getTypeEnv typeEnv)
                  c <- envToC env
                  return ("//Types:\n" ++ typeDecl ++ "\n\n//Declarations:\n" ++ decl ++ "\n\n//Definitions:\n" ++ c)
     case src of
       Left err ->
         liftIO $ do putStrLnWithColor Red ("[CODEGEN ERROR] " ++ show err)
                     return dynamicNil
       Right okSrc ->
         liftIO $ do let compiler = projectCompiler proj
                         echoCompilationCommand = projectEchoCompilationCommand proj
                         incl = projectIncludesToC proj
                         includeCorePath = " -I" ++ projectCarpDir proj ++ "/core/ "
                         switches = " -g "
                         flags = projectFlags proj ++ includeCorePath ++ switches
                         outDir = projectOutDir proj
                         outMain = outDir ++ "main.c"
                         outExe = outDir ++ "a.out"
                         outLib = outDir ++ "lib.so"
                     createDirectoryIfMissing False outDir
                     writeFile outMain (incl ++ okSrc)
                     case Map.lookup "main" (envBindings env) of
                       Just _ -> do let cmd = compiler ++ " " ++ outMain ++ " -o " ++ outExe ++ " " ++ flags
                                    when echoCompilationCommand (putStrLn cmd)
                                    callCommand cmd
                                    when (execMode == Repl) (putStrLn ("Compiled to '" ++ outExe ++ "'"))
                                    return dynamicNil
                       Nothing -> do let cmd = compiler ++ " " ++ outMain ++ " -shared -o " ++ outLib ++ " " ++ flags
                                     when echoCompilationCommand (putStrLn cmd)
                                     callCommand cmd
                                     when (execMode == Repl) (putStrLn ("Compiled to '" ++ outLib ++ "'"))
                                     return dynamicNil

-- | Command for printing all the bindings in the current environment.
commandListBindings :: CommandCallback
commandListBindings args =
  do ctx <- get
     liftIO $ do putStrLn "Types:\n"
                 putStrLn (prettyEnvironment (getTypeEnv (contextTypeEnv ctx)))
                 putStrLn "\nGlobal environment:\n"
                 putStrLn (prettyEnvironment (contextGlobalEnv ctx))
                 putStrLn ""
                 return dynamicNil

-- | Command for printing help.
commandHelp :: CommandCallback

commandHelp [XObj (Str "about") _ _] =
  liftIO $ do putStrLn "Carp is an ongoing research project by Erik SvedÃ¤ng, et al."
              putStrLn ""
              putStrLn "Licensed under the Apache License, Version 2.0 (the \"License\"); \n\
                       \you may not use this file except in compliance with the License. \n\
                       \You may obtain a copy of the License at \n\
                       \http://www.apache.org/licenses/LICENSE-2.0"
              putStrLn ""
              putStrLn "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY \n\
                       \EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n\
                       \IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR \n\
                       \PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE \n\
                       \LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n\
                       \CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n\
                       \SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR \n\
                       \BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, \n\
                       \WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE \n\
                       \OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n\
                       \IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
              putStrLn ""
              return dynamicNil

commandHelp [XObj (Str "language") _ _] =
  liftIO $ do putStrLn "Special forms:"
              putStrLn "(if <condition> <then> <else>)"
              putStrLn "(while <condition> <body>)"
              putStrLn "(do <statement1> <statement2> ... <exprN>)"
              putStrLn "(let [<sym1> <expr1> <name2> <expr2> ...] <body>)"
              --putStrLn "(fn [<args>] <body>)"
              putStrLn "(the <type> <expression>)"
              putStrLn "(ref <expression>)"
              putStrLn "(address <expr>)"
              putStrLn "(set! <var> <value>)"
              putStrLn "(break)"
              putStrLn ""
              putStrLn "To use functions in modules without qualifying them:"
              putStrLn "(use <module>)"
              putStrLn "(with <module> <form>)"
              putStrLn ""
              putStrLn ("Valid non-alphanumerics: " ++ validCharacters)
              putStrLn ""
              putStrLn "Number literals:"
              putStrLn "1      Int"
              putStrLn "1l     Long"
              putStrLn "1.0    Double"
              putStrLn "1.0f   Float"
              putStrLn ""
              putStrLn "Reader macros:"
              putStrLn "&<expr>   (ref <expr>)"
              putStrLn "@<expr>   (copy <expr>)"
              putStrLn ""
              return dynamicNil

commandHelp [XObj (Str "macros") _ _] =
  liftIO $ do putStrLn "To inspect what macros expand to:"
              putStrLn "(expand <quoted expression>)"
              putStrLn ""
              putStrLn "Some useful macros:"
              putStrLn "(cond <condition1> <expr1> ... <else-condition>)"
              putStrLn "(case <expr> <compare-this-1> <expr1> ... <else-condition>)"
              putStrLn "(when <condition> <body>)"
              putStrLn "(for [<var> <from> <to>] <body>)"
              putStrLn "(=> <expr> <func1> <func2> ...)"
              putStrLn "(==> <expr> <func1> <func2> ...)"
              putStrLn ""
              return dynamicNil

commandHelp [XObj (Str "structs") _ _] =
  liftIO $ do putStrLn "A type definition will generate the following methods:"
              putStrLn "Getters  (<method-name> (Ref <struct>))"
              putStrLn "Setters  (set-<method-name> <struct> <new-value>)"
              putStrLn "Updaters (update-<method-name> <struct> <new-value>)"
              putStrLn "init (stack allocation)"
              putStrLn "new (heap allocation)"
              putStrLn "copy"
              putStrLn "delete (used internally, no need to call this explicitly)"
              putStrLn ""
              return dynamicNil

commandHelp [XObj(Str "shortcuts") _ _] =
  liftIO $ do putStrLn "GHC-style shortcuts at the repl:"
              putStrLn "(reload)   :r"
              putStrLn "(build)    :b"
              putStrLn "(run)      :x"
              putStrLn "(cat)      :c"
              putStrLn "(env)      :e"
              putStrLn "(help)     :h"
              putStrLn "(project)  :p"
              putStrLn "(quit)     :q"
              putStrLn ""
              putStrLn "The shortcuts can be combined like this: \":rbx\""
              putStrLn ""
              return dynamicNil

commandHelp [] =
  liftIO $ do putStrLn "Compiler commands:"
              putStrLn "(load <file>)      - Load a .carp file, evaluate its content, and add it to the project."
              putStrLn "(reload)           - Reload all the project files."
              putStrLn "(build)            - Produce an executable or shared library."
              putStrLn "(run)              - Run the executable produced by 'build' (if available)."
              putStrLn "(cat)              - Look at the generated C code (make sure you build first)."
              putStrLn "(env)              - List the bindings in the global environment."
              putStrLn "(type <symbol>)    - Get the type of a binding."
              putStrLn "(info <symbol>)    - Get information about a binding."
              putStrLn "(project)          - Display information about your project."
              putStrLn "(quit)             - Terminate this Carp REPL."
              putStrLn "(help <chapter>)   - Available chapters: \"language\", \"macros\", \"structs\", \"shortcuts\", \"about\"."
              putStrLn ""
              putStrLn "To define things:"
              putStrLn "(def <name> <constant>)           - Define a global variable."
              putStrLn "(defn <name> [<args>] <body>)     - Define a function."
              putStrLn "(module <name> <def1> <def2> ...) - Define a module and/or add definitions to an existing one."
              putStrLn "(deftype <name> ...)              - Define a new type."
              putStrLn "(register <name> <type>)          - Make an external variable or function available for usage."
              putStrLn "(defalias <name> <type>)          - Create another name for a type."
              putStrLn ""
              putStrLn "C-compiler configuration:"
              putStrLn "(system-include <file>)          - Include a system header file."
              putStrLn "(local-include <file>)           - Include a local header file."
              putStrLn "(add-cflag <flag>)               - Add a cflag to the compilation step."
              putStrLn "(add-lib <flag>)                 - Add a library flag to the compilation step."
              putStrLn "(project-set! <setting> <value>) - Change a project setting (not fully implemented)."
              putStrLn ""
              putStrLn "Compiler flags:"
              putStrLn "-b                               - Build."
              putStrLn "-x                               - Build and run."
              return dynamicNil

commandHelp args =
  do liftIO $ putStrLn ("Can't find help for " ++ joinWithComma (map pretty args))
     return dynamicNil

-- | Command for printing information about the current project.
commandProject :: CommandCallback
commandProject args =
  do ctx <- get
     liftIO (print (contextProj ctx))
     return dynamicNil

-- | Command for printing a message to the screen.
commandPrint :: CommandCallback
commandPrint args =
  do liftIO $ mapM_ (putStrLn . pretty) args
     return dynamicNil

-- | Command for getting the name of the operating system you're on.
commandOS :: CommandCallback
commandOS _ =
  return (Right (XObj (Str os) (Just dummyInfo) (Just StringTy)))

-- | Command for adding a header file include to the project.
commandAddInclude :: (String -> Includer) -> CommandCallback
commandAddInclude includerConstructor [XObj (Str file) _ _] =
  do ctx <- get
     let proj = contextProj ctx
         includer = includerConstructor file
         includers = projectIncludes proj
         includers' = if includer `elem` includers
                      then includers
                      else includer : includers
         proj' = proj { projectIncludes = includers' }
     put (ctx { contextProj = proj' })
     return dynamicNil

commandAddSystemInclude = commandAddInclude SystemInclude
commandAddLocalInclude  = commandAddInclude LocalInclude

commandIsList :: CommandCallback
commandIsList [x] =
  case x of
    XObj (Lst _) _ _ -> return (Right trueXObj)
    _ -> return (Right falseXObj)
commandIsList _ =
  do liftIO $ putStrLnWithColor Red "Invalid args to 'list?'"
     return dynamicNil

commandCount [x] =
  case x of
    XObj (Lst lst) _ _ -> return (Right (XObj (Num IntTy (fromIntegral (length lst))) Nothing Nothing))
    XObj (Arr arr) _ _ -> return (Right (XObj (Num IntTy (fromIntegral (length arr))) Nothing Nothing))
    _ -> return (Left (EvalError ("Applying 'count' to non-list: " ++ pretty x ++ " at " ++ prettyInfoFromXObj x)))
commandCount args =
  do liftIO $ putStrLnWithColor Red ("Invalid args to 'count': " ++ joinWithComma (map pretty args))
     return dynamicNil

commandCar [x] =
  case x of
    XObj (Lst (car : _)) _ _ -> return (Right car)
    XObj (Arr (car : _)) _ _ -> return (Right car)
    _ -> return (Left (EvalError ("Applying 'car' to non-list: " ++ pretty x)))
commandCar args =
  do liftIO $ putStrLnWithColor Red ("Invalid args to 'car': " ++ joinWithComma (map pretty args))
     return dynamicNil

commandCdr [x] =
  case x of
    XObj (Lst (_ : cdr)) _ _ -> return (Right (XObj (Lst cdr) Nothing Nothing))
    XObj (Arr (_ : cdr)) _ _ -> return (Right (XObj (Arr cdr) Nothing Nothing))
    _ -> return (Left (EvalError "Applying 'cdr' to non-list or empty list"))
commandCdr args =
  do liftIO $ putStrLnWithColor Red ("Invalid args to 'cdr': " ++ joinWithComma (map pretty args))
     return dynamicNil

commandLast [x] =
  case x of
    XObj (Lst lst) _ _ -> return (Right (last lst))
    XObj (Arr arr) _ _ -> return (Right (last arr))
    _ -> return (Left (EvalError "Applying 'last' to non-list or empty list."))
commandLast args =
  do liftIO $ putStrLnWithColor Red ("Invalid args to 'last': " ++ joinWithComma (map pretty args))
     return dynamicNil

commandAllButLast [x] =
  case x of
    XObj (Lst lst) _ _ -> return (Right (XObj (Lst (init lst)) Nothing Nothing))
    XObj (Arr arr) _ _ -> return (Right (XObj (Arr (init arr)) Nothing Nothing))
    _ -> return (Left (EvalError "Applying 'all-but-last' to non-list or empty list."))
commandAllButLast args =
  do liftIO $ putStrLnWithColor Red ("Invalid args to 'all-but-last': " ++ joinWithComma (map pretty args))
     return dynamicNil

commandCons [x, xs] =
  case xs of
    XObj (Lst lst) _ _ -> return (Right (XObj (Lst (x : lst)) (info x) (ty x))) -- TODO: probably not correct to just copy 'i' and 't'?
    _ -> return (Left (EvalError "Applying 'cons' to non-list or empty list."))
commandCons args =
  do liftIO $ putStrLnWithColor Red ("Invalid args to 'cons': " ++ joinWithComma (map pretty args))
     return dynamicNil

commandConsLast [x, xs] =
  case xs of
    XObj (Lst lst) i t -> return (Right (XObj (Lst (lst ++ [x])) i t)) -- TODO: should they get their own i:s and t:s
    _ -> return (Left (EvalError "Applying 'cons-last' to non-list or empty list."))
commandConsLast args =
  do liftIO $ putStrLnWithColor Red ("Invalid args to 'cons-last': " ++ joinWithComma (map pretty args))
     return dynamicNil

commandAppend [xs, ys] =
  case (xs, ys) of
    (XObj (Lst lst1) i t, XObj (Lst lst2) _ _) ->
      return (Right (XObj (Lst (lst1 ++ lst2)) i t)) -- TODO: should they get their own i:s and t:s
    _ ->
      return (Left (EvalError "Applying 'append' to non-list or empty list."))
commandAppend args =
  do liftIO $ putStrLnWithColor Red ("Invalid args to 'append': " ++ joinWithComma (map pretty args))
     return dynamicNil

commandMacroError [msg] =
  case msg of
    XObj (Str msg) _ _ -> return (Left (EvalError msg))
    _                  -> return (Left (EvalError "Calling 'macro-error' with non-string argument"))

-- -- | This function will show the resulting code of non-definitions.
-- -- | i.e. (Int.+ 2 3) => "_0 = 2 + 3"
-- consumeExpr :: Context -> XObj -> IO ReplCommand
-- consumeExpr ctx@(Context globalEnv typeEnv _ _ _ _) xobj =
--   do (expansionResult, newCtx) <- runStateT (expandAll globalEnv xobj) ctx
--      case expansionResult of
--        Left err -> return (ReplMacroError (show err))
--        Right expanded ->
--          case annotate typeEnv globalEnv (setFullyQualifiedSymbols typeEnv globalEnv expanded) of
--            Left err -> return (ReplTypeError (show err))
--            Right annXObjs -> return (ListOfCallbacks (map printC annXObjs))

-- printC :: XObj -> CommandCallback
-- printC xobj =
--   case checkForUnresolvedSymbols xobj of
--     Left e ->
--       (const (commandPrint [(XObj (Str (strWithColor Red (show e ++ ", can't print resulting code.\n"))) Nothing Nothing)]))
--     Right _ ->
--       (const (commandPrint [(XObj (Str (strWithColor Green (toC xobj))) Nothing Nothing)]))
